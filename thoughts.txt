- columns out must be if not static, at least statically enumerable

oem str
release str

jira_ticket:
> like :ticket "INTEG%"
> = :issuetype "Task"
> ilike :summary `%${oem}%${release}%tracking ticket%`
^ :rank order :created

sniff_pack str
all_success [str]
after datetime
before datetime
pre_post_events relation  # how do we "import" these
groups [header]

run_end_times:
    run:
    J result:
    > = :exit_status 0
    > bool :is_integrated_release
    > = :pack sniff_pack
    > in :jenkins_result all_success
    ^ :duration make_interval :duration
    ^ :end_time + :timestamp :duration
    G :run_id
        :latest_end_time max :end_time
    v :run_id :end_time :pointless_column

run:
J
    run_end_times:
    v :run_id :end_time
> > :end_time after
> < :end_time before
J result:
J pre_post_events:
J report:


previous_to_release_id:
    run:
    v :run_id :release
    > = :release previous_to_release
    G :release
        :min_run_id min :run_id
    v :run_id
    > one

all_possible_groups:
    run:
    v groups
    > and
        (map groups) `isnot ${} null`

reverse_indexed_in_groups:
    run:
    ^ :n order :run_id desc=True partition_by=groups
    > bool :is_integrated_release
    > not :building
    > < :run_id previous_to_release_id:
    v :run_id :n

counts_seen:
    run:
    v :run_id groups
    > in :run_id
        reverse_indexed_in_groups:
        > <= :n max_n_runs
        v :run_id
    J
        result:
        v :run_id :result_id :duration
    G :run_id
        :number_of_results count :result_id
        :total_duration sum :duration

all_possible_groups:
Outer counts_seen:
G groups
    :median percentile 0.7 :number_of_results
    :duration percentile 0.7 :total_duration
^ :rank order groups


// functions

Rename relation: old new
    final_headers
        relation:*
        - old

    relation:
    ^ old identity new
    v final_headers

Outer relation: right:
    joined:
        relation:
        J right:

    relation:
    -
        joined:
        v relation:*
    X
        right:
        > first
        (map right:*) `^ ${} make_null`
    | joined:


Namespace relation: namespace ignore
    to_rename
        relation:*
        - ignore

    relation:
    (map to_rename) `Rename ${} ${namespace}.${}`


// lists are treated as sets
//    [:foo :bar]


Base operators:
> v ^ X | - J G

PROGRAM

BLOCK

BLOCK

BLOCK

Forms:

Relation
    BLOCK

Var
    BLOCK

Def Arg Arg ...
    BLOCK

G Header Header ...
    AGG_BLOCK

LINE
    BLOCK

Operators:
> Func Arg Arg ...
v Header Header ...
^ Header Func Arg Arg ...
X Arg
| Arg
- Arg
J Arg
G _see above_



Parse order:
- expand macros
- expand sets?
- inline Gs
- inline blocks
- inline assignments?


Design choices:
- Each line of dawdle should map deterministically both ways to the JSON AST
- Given an environment, it should always be possible to determine the schema at any line
- Given test values, it should always be possible to determine the value at any line
- Functions can only be composed of the base operators and other functions
- Sets are always splatted in place
- (map some_set) is a macro


Other things to think about:
- datetime type - ISO 8601 ~2018-07-20T10:25:25+00:00 ~P3Y6M4DT12H30M5S
- table literals
- nesting syntax
- decimal type?
- integer type?


df:
    a | b | c | d
    ---------------
    1 | 2 | 3 | 4
    1 | 2 | 6 | 7
    8 | 9 | 0 | 7

S
    a_s :a order :a
        c_s :c :d order :c

{
    a_s: [
        {
            a: 1,
            c_s: [{c: 3, d: 4}, {c: 6, d: 7}]
        },
        {
            a: 8,
            c_s: [{c: 0, d: 7}]
        }
    ]
}

S
    d_s :d
        a_s :b
    c_s :c :d

{
    d_s: [
        {
            d: 4,
            a_s: [{b: 2}]},
        {
            d: 7,
            as: [{b: 2}, {b: 9}],
        }
    ]
    c_s: [{c: 3, d: 4}, {c: 6, d: 7}, {c: 0, d: 7}]
}

